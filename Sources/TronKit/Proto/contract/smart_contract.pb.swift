// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/contract/smart_contract.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct Protocol_SmartContract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var originAddress: Data = .init()

    var contractAddress: Data = .init()

    var abi: Protocol_SmartContract.ABI {
        get { _abi ?? Protocol_SmartContract.ABI() }
        set { _abi = newValue }
    }

    /// Returns true if `abi` has been explicitly set.
    var hasAbi: Bool { _abi != nil }
    /// Clears the value of `abi`. Subsequent reads from it will return its default value.
    mutating func clearAbi() { _abi = nil }

    var bytecode: Data = .init()

    var callValue: Int64 = 0

    var consumeUserResourcePercent: Int64 = 0

    var name: String = .init()

    var originEnergyLimit: Int64 = 0

    var codeHash: Data = .init()

    var trxHash: Data = .init()

    var version: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ABI {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var entrys: [Protocol_SmartContract.ABI.Entry] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        struct Entry {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var anonymous: Bool = false

            var constant: Bool = false

            var name: String = .init()

            var inputs: [Protocol_SmartContract.ABI.Entry.Param] = []

            var outputs: [Protocol_SmartContract.ABI.Entry.Param] = []

            var type: Protocol_SmartContract.ABI.Entry.EntryType = .unknownEntryType

            var payable: Bool = false

            var stateMutability: Protocol_SmartContract.ABI.Entry.StateMutabilityType = .unknownMutabilityType

            var unknownFields = SwiftProtobuf.UnknownStorage()

            enum EntryType: SwiftProtobuf.Enum {
                typealias RawValue = Int
                case unknownEntryType // = 0
                case constructor // = 1
                case function // = 2
                case event // = 3
                case fallback // = 4
                case receive // = 5
                case error // = 6
                case UNRECOGNIZED(Int)

                init() {
                    self = .unknownEntryType
                }

                init?(rawValue: Int) {
                    switch rawValue {
                    case 0: self = .unknownEntryType
                    case 1: self = .constructor
                    case 2: self = .function
                    case 3: self = .event
                    case 4: self = .fallback
                    case 5: self = .receive
                    case 6: self = .error
                    default: self = .UNRECOGNIZED(rawValue)
                    }
                }

                var rawValue: Int {
                    switch self {
                    case .unknownEntryType: return 0
                    case .constructor: return 1
                    case .function: return 2
                    case .event: return 3
                    case .fallback: return 4
                    case .receive: return 5
                    case .error: return 6
                    case let .UNRECOGNIZED(i): return i
                    }
                }
            }

            enum StateMutabilityType: SwiftProtobuf.Enum {
                typealias RawValue = Int
                case unknownMutabilityType // = 0
                case pure // = 1
                case view // = 2
                case nonpayable // = 3
                case payable // = 4
                case UNRECOGNIZED(Int)

                init() {
                    self = .unknownMutabilityType
                }

                init?(rawValue: Int) {
                    switch rawValue {
                    case 0: self = .unknownMutabilityType
                    case 1: self = .pure
                    case 2: self = .view
                    case 3: self = .nonpayable
                    case 4: self = .payable
                    default: self = .UNRECOGNIZED(rawValue)
                    }
                }

                var rawValue: Int {
                    switch self {
                    case .unknownMutabilityType: return 0
                    case .pure: return 1
                    case .view: return 2
                    case .nonpayable: return 3
                    case .payable: return 4
                    case let .UNRECOGNIZED(i): return i
                    }
                }
            }

            struct Param {
                // SwiftProtobuf.Message conformance is added in an extension below. See the
                // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
                // methods supported on all messages.

                var indexed: Bool = false

                var name: String = .init()

                /// SolidityType type = 3;
                var type: String = .init()

                var unknownFields = SwiftProtobuf.UnknownStorage()

                init() {}
            }

            init() {}
        }

        init() {}
    }

    init() {}

    fileprivate var _abi: Protocol_SmartContract.ABI?
}

#if swift(>=4.2)

    extension Protocol_SmartContract.ABI.Entry.EntryType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Protocol_SmartContract.ABI.Entry.EntryType] = [
            .unknownEntryType,
            .constructor,
            .function,
            .event,
            .fallback,
            .receive,
            .error,
        ]
    }

    extension Protocol_SmartContract.ABI.Entry.StateMutabilityType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [Protocol_SmartContract.ABI.Entry.StateMutabilityType] = [
            .unknownMutabilityType,
            .pure,
            .view,
            .nonpayable,
            .payable,
        ]
    }

#endif // swift(>=4.2)

struct Protocol_ContractState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var energyUsage: Int64 = 0

    var energyFactor: Int64 = 0

    var updateCycle: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Protocol_CreateSmartContract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAddress: Data = .init()

    var newContract: Protocol_SmartContract {
        get { _newContract ?? Protocol_SmartContract() }
        set { _newContract = newValue }
    }

    /// Returns true if `newContract` has been explicitly set.
    var hasNewContract: Bool { _newContract != nil }
    /// Clears the value of `newContract`. Subsequent reads from it will return its default value.
    mutating func clearNewContract() { _newContract = nil }

    var callTokenValue: Int64 = 0

    var tokenID: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _newContract: Protocol_SmartContract?
}

struct Protocol_TriggerSmartContract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAddress: Data = .init()

    var contractAddress: Data = .init()

    var callValue: Int64 = 0

    var data: Data = .init()

    var callTokenValue: Int64 = 0

    var tokenID: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Protocol_ClearABIContract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAddress: Data = .init()

    var contractAddress: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Protocol_UpdateSettingContract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAddress: Data = .init()

    var contractAddress: Data = .init()

    var consumeUserResourcePercent: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Protocol_UpdateEnergyLimitContract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAddress: Data = .init()

    var contractAddress: Data = .init()

    var originEnergyLimit: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Protocol_SmartContractDataWrapper {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var smartContract: Protocol_SmartContract {
        get { _smartContract ?? Protocol_SmartContract() }
        set { _smartContract = newValue }
    }

    /// Returns true if `smartContract` has been explicitly set.
    var hasSmartContract: Bool { _smartContract != nil }
    /// Clears the value of `smartContract`. Subsequent reads from it will return its default value.
    mutating func clearSmartContract() { _smartContract = nil }

    var runtimecode: Data = .init()

    var contractState: Protocol_ContractState {
        get { _contractState ?? Protocol_ContractState() }
        set { _contractState = newValue }
    }

    /// Returns true if `contractState` has been explicitly set.
    var hasContractState: Bool { _contractState != nil }
    /// Clears the value of `contractState`. Subsequent reads from it will return its default value.
    mutating func clearContractState() { _contractState = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    private var _smartContract: Protocol_SmartContract?
    private var _contractState: Protocol_ContractState?
}

#if swift(>=5.5) && canImport(_Concurrency)
    extension Protocol_SmartContract: @unchecked Sendable {}
    extension Protocol_SmartContract.ABI: @unchecked Sendable {}
    extension Protocol_SmartContract.ABI.Entry: @unchecked Sendable {}
    extension Protocol_SmartContract.ABI.Entry.EntryType: @unchecked Sendable {}
    extension Protocol_SmartContract.ABI.Entry.StateMutabilityType: @unchecked Sendable {}
    extension Protocol_SmartContract.ABI.Entry.Param: @unchecked Sendable {}
    extension Protocol_ContractState: @unchecked Sendable {}
    extension Protocol_CreateSmartContract: @unchecked Sendable {}
    extension Protocol_TriggerSmartContract: @unchecked Sendable {}
    extension Protocol_ClearABIContract: @unchecked Sendable {}
    extension Protocol_UpdateSettingContract: @unchecked Sendable {}
    extension Protocol_UpdateEnergyLimitContract: @unchecked Sendable {}
    extension Protocol_SmartContractDataWrapper: @unchecked Sendable {}
#endif // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "protocol"

extension Protocol_SmartContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SmartContract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "origin_address"),
        2: .standard(proto: "contract_address"),
        3: .same(proto: "abi"),
        4: .same(proto: "bytecode"),
        5: .standard(proto: "call_value"),
        6: .standard(proto: "consume_user_resource_percent"),
        7: .same(proto: "name"),
        8: .standard(proto: "origin_energy_limit"),
        9: .standard(proto: "code_hash"),
        10: .standard(proto: "trx_hash"),
        11: .same(proto: "version"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &originAddress)
            case 2: try decoder.decodeSingularBytesField(value: &contractAddress)
            case 3: try decoder.decodeSingularMessageField(value: &_abi)
            case 4: try decoder.decodeSingularBytesField(value: &bytecode)
            case 5: try decoder.decodeSingularInt64Field(value: &callValue)
            case 6: try decoder.decodeSingularInt64Field(value: &consumeUserResourcePercent)
            case 7: try decoder.decodeSingularStringField(value: &name)
            case 8: try decoder.decodeSingularInt64Field(value: &originEnergyLimit)
            case 9: try decoder.decodeSingularBytesField(value: &codeHash)
            case 10: try decoder.decodeSingularBytesField(value: &trxHash)
            case 11: try decoder.decodeSingularInt32Field(value: &version)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !originAddress.isEmpty {
            try visitor.visitSingularBytesField(value: originAddress, fieldNumber: 1)
        }
        if !contractAddress.isEmpty {
            try visitor.visitSingularBytesField(value: contractAddress, fieldNumber: 2)
        }
        try { if let v = self._abi {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !bytecode.isEmpty {
            try visitor.visitSingularBytesField(value: bytecode, fieldNumber: 4)
        }
        if callValue != 0 {
            try visitor.visitSingularInt64Field(value: callValue, fieldNumber: 5)
        }
        if consumeUserResourcePercent != 0 {
            try visitor.visitSingularInt64Field(value: consumeUserResourcePercent, fieldNumber: 6)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 7)
        }
        if originEnergyLimit != 0 {
            try visitor.visitSingularInt64Field(value: originEnergyLimit, fieldNumber: 8)
        }
        if !codeHash.isEmpty {
            try visitor.visitSingularBytesField(value: codeHash, fieldNumber: 9)
        }
        if !trxHash.isEmpty {
            try visitor.visitSingularBytesField(value: trxHash, fieldNumber: 10)
        }
        if version != 0 {
            try visitor.visitSingularInt32Field(value: version, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_SmartContract, rhs: Protocol_SmartContract) -> Bool {
        if lhs.originAddress != rhs.originAddress { return false }
        if lhs.contractAddress != rhs.contractAddress { return false }
        if lhs._abi != rhs._abi { return false }
        if lhs.bytecode != rhs.bytecode { return false }
        if lhs.callValue != rhs.callValue { return false }
        if lhs.consumeUserResourcePercent != rhs.consumeUserResourcePercent { return false }
        if lhs.name != rhs.name { return false }
        if lhs.originEnergyLimit != rhs.originEnergyLimit { return false }
        if lhs.codeHash != rhs.codeHash { return false }
        if lhs.trxHash != rhs.trxHash { return false }
        if lhs.version != rhs.version { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_SmartContract.ABI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Protocol_SmartContract.protoMessageName + ".ABI"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entrys"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &entrys)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !entrys.isEmpty {
            try visitor.visitRepeatedMessageField(value: entrys, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_SmartContract.ABI, rhs: Protocol_SmartContract.ABI) -> Bool {
        if lhs.entrys != rhs.entrys { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_SmartContract.ABI.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Protocol_SmartContract.ABI.protoMessageName + ".Entry"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "anonymous"),
        2: .same(proto: "constant"),
        3: .same(proto: "name"),
        4: .same(proto: "inputs"),
        5: .same(proto: "outputs"),
        6: .same(proto: "type"),
        7: .same(proto: "payable"),
        8: .same(proto: "stateMutability"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &anonymous)
            case 2: try decoder.decodeSingularBoolField(value: &constant)
            case 3: try decoder.decodeSingularStringField(value: &name)
            case 4: try decoder.decodeRepeatedMessageField(value: &inputs)
            case 5: try decoder.decodeRepeatedMessageField(value: &outputs)
            case 6: try decoder.decodeSingularEnumField(value: &type)
            case 7: try decoder.decodeSingularBoolField(value: &payable)
            case 8: try decoder.decodeSingularEnumField(value: &stateMutability)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if anonymous != false {
            try visitor.visitSingularBoolField(value: anonymous, fieldNumber: 1)
        }
        if constant != false {
            try visitor.visitSingularBoolField(value: constant, fieldNumber: 2)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 3)
        }
        if !inputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: inputs, fieldNumber: 4)
        }
        if !outputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: outputs, fieldNumber: 5)
        }
        if type != .unknownEntryType {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 6)
        }
        if payable != false {
            try visitor.visitSingularBoolField(value: payable, fieldNumber: 7)
        }
        if stateMutability != .unknownMutabilityType {
            try visitor.visitSingularEnumField(value: stateMutability, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_SmartContract.ABI.Entry, rhs: Protocol_SmartContract.ABI.Entry) -> Bool {
        if lhs.anonymous != rhs.anonymous { return false }
        if lhs.constant != rhs.constant { return false }
        if lhs.name != rhs.name { return false }
        if lhs.inputs != rhs.inputs { return false }
        if lhs.outputs != rhs.outputs { return false }
        if lhs.type != rhs.type { return false }
        if lhs.payable != rhs.payable { return false }
        if lhs.stateMutability != rhs.stateMutability { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_SmartContract.ABI.Entry.EntryType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UnknownEntryType"),
        1: .same(proto: "Constructor"),
        2: .same(proto: "Function"),
        3: .same(proto: "Event"),
        4: .same(proto: "Fallback"),
        5: .same(proto: "Receive"),
        6: .same(proto: "Error"),
    ]
}

extension Protocol_SmartContract.ABI.Entry.StateMutabilityType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "UnknownMutabilityType"),
        1: .same(proto: "Pure"),
        2: .same(proto: "View"),
        3: .same(proto: "Nonpayable"),
        4: .same(proto: "Payable"),
    ]
}

extension Protocol_SmartContract.ABI.Entry.Param: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Protocol_SmartContract.ABI.Entry.protoMessageName + ".Param"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "indexed"),
        2: .same(proto: "name"),
        3: .same(proto: "type"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &indexed)
            case 2: try decoder.decodeSingularStringField(value: &name)
            case 3: try decoder.decodeSingularStringField(value: &type)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if indexed != false {
            try visitor.visitSingularBoolField(value: indexed, fieldNumber: 1)
        }
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 2)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_SmartContract.ABI.Entry.Param, rhs: Protocol_SmartContract.ABI.Entry.Param) -> Bool {
        if lhs.indexed != rhs.indexed { return false }
        if lhs.name != rhs.name { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_ContractState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ContractState"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "energy_usage"),
        2: .standard(proto: "energy_factor"),
        3: .standard(proto: "update_cycle"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt64Field(value: &energyUsage)
            case 2: try decoder.decodeSingularInt64Field(value: &energyFactor)
            case 3: try decoder.decodeSingularInt64Field(value: &updateCycle)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if energyUsage != 0 {
            try visitor.visitSingularInt64Field(value: energyUsage, fieldNumber: 1)
        }
        if energyFactor != 0 {
            try visitor.visitSingularInt64Field(value: energyFactor, fieldNumber: 2)
        }
        if updateCycle != 0 {
            try visitor.visitSingularInt64Field(value: updateCycle, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ContractState, rhs: Protocol_ContractState) -> Bool {
        if lhs.energyUsage != rhs.energyUsage { return false }
        if lhs.energyFactor != rhs.energyFactor { return false }
        if lhs.updateCycle != rhs.updateCycle { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_CreateSmartContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CreateSmartContract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "owner_address"),
        2: .standard(proto: "new_contract"),
        3: .standard(proto: "call_token_value"),
        4: .standard(proto: "token_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 2: try decoder.decodeSingularMessageField(value: &_newContract)
            case 3: try decoder.decodeSingularInt64Field(value: &callTokenValue)
            case 4: try decoder.decodeSingularInt64Field(value: &tokenID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 1)
        }
        try { if let v = self._newContract {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if callTokenValue != 0 {
            try visitor.visitSingularInt64Field(value: callTokenValue, fieldNumber: 3)
        }
        if tokenID != 0 {
            try visitor.visitSingularInt64Field(value: tokenID, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_CreateSmartContract, rhs: Protocol_CreateSmartContract) -> Bool {
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs._newContract != rhs._newContract { return false }
        if lhs.callTokenValue != rhs.callTokenValue { return false }
        if lhs.tokenID != rhs.tokenID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_TriggerSmartContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".TriggerSmartContract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "owner_address"),
        2: .standard(proto: "contract_address"),
        3: .standard(proto: "call_value"),
        4: .same(proto: "data"),
        5: .standard(proto: "call_token_value"),
        6: .standard(proto: "token_id"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 2: try decoder.decodeSingularBytesField(value: &contractAddress)
            case 3: try decoder.decodeSingularInt64Field(value: &callValue)
            case 4: try decoder.decodeSingularBytesField(value: &data)
            case 5: try decoder.decodeSingularInt64Field(value: &callTokenValue)
            case 6: try decoder.decodeSingularInt64Field(value: &tokenID)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 1)
        }
        if !contractAddress.isEmpty {
            try visitor.visitSingularBytesField(value: contractAddress, fieldNumber: 2)
        }
        if callValue != 0 {
            try visitor.visitSingularInt64Field(value: callValue, fieldNumber: 3)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 4)
        }
        if callTokenValue != 0 {
            try visitor.visitSingularInt64Field(value: callTokenValue, fieldNumber: 5)
        }
        if tokenID != 0 {
            try visitor.visitSingularInt64Field(value: tokenID, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_TriggerSmartContract, rhs: Protocol_TriggerSmartContract) -> Bool {
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs.contractAddress != rhs.contractAddress { return false }
        if lhs.callValue != rhs.callValue { return false }
        if lhs.data != rhs.data { return false }
        if lhs.callTokenValue != rhs.callTokenValue { return false }
        if lhs.tokenID != rhs.tokenID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_ClearABIContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ClearABIContract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "owner_address"),
        2: .standard(proto: "contract_address"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 2: try decoder.decodeSingularBytesField(value: &contractAddress)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 1)
        }
        if !contractAddress.isEmpty {
            try visitor.visitSingularBytesField(value: contractAddress, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_ClearABIContract, rhs: Protocol_ClearABIContract) -> Bool {
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs.contractAddress != rhs.contractAddress { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_UpdateSettingContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateSettingContract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "owner_address"),
        2: .standard(proto: "contract_address"),
        3: .standard(proto: "consume_user_resource_percent"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 2: try decoder.decodeSingularBytesField(value: &contractAddress)
            case 3: try decoder.decodeSingularInt64Field(value: &consumeUserResourcePercent)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 1)
        }
        if !contractAddress.isEmpty {
            try visitor.visitSingularBytesField(value: contractAddress, fieldNumber: 2)
        }
        if consumeUserResourcePercent != 0 {
            try visitor.visitSingularInt64Field(value: consumeUserResourcePercent, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_UpdateSettingContract, rhs: Protocol_UpdateSettingContract) -> Bool {
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs.contractAddress != rhs.contractAddress { return false }
        if lhs.consumeUserResourcePercent != rhs.consumeUserResourcePercent { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_UpdateEnergyLimitContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UpdateEnergyLimitContract"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "owner_address"),
        2: .standard(proto: "contract_address"),
        3: .standard(proto: "origin_energy_limit"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &ownerAddress)
            case 2: try decoder.decodeSingularBytesField(value: &contractAddress)
            case 3: try decoder.decodeSingularInt64Field(value: &originEnergyLimit)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !ownerAddress.isEmpty {
            try visitor.visitSingularBytesField(value: ownerAddress, fieldNumber: 1)
        }
        if !contractAddress.isEmpty {
            try visitor.visitSingularBytesField(value: contractAddress, fieldNumber: 2)
        }
        if originEnergyLimit != 0 {
            try visitor.visitSingularInt64Field(value: originEnergyLimit, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_UpdateEnergyLimitContract, rhs: Protocol_UpdateEnergyLimitContract) -> Bool {
        if lhs.ownerAddress != rhs.ownerAddress { return false }
        if lhs.contractAddress != rhs.contractAddress { return false }
        if lhs.originEnergyLimit != rhs.originEnergyLimit { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Protocol_SmartContractDataWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SmartContractDataWrapper"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "smart_contract"),
        2: .same(proto: "runtimecode"),
        3: .standard(proto: "contract_state"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_smartContract)
            case 2: try decoder.decodeSingularBytesField(value: &runtimecode)
            case 3: try decoder.decodeSingularMessageField(value: &_contractState)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._smartContract {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !runtimecode.isEmpty {
            try visitor.visitSingularBytesField(value: runtimecode, fieldNumber: 2)
        }
        try { if let v = self._contractState {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Protocol_SmartContractDataWrapper, rhs: Protocol_SmartContractDataWrapper) -> Bool {
        if lhs._smartContract != rhs._smartContract { return false }
        if lhs.runtimecode != rhs.runtimecode { return false }
        if lhs._contractState != rhs._contractState { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
